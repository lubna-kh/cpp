* Iterators (what they are & categories):

* Concept & purpose:

- Iterators are generalized pointers to traverse containers. begin() and end() bracket the range.
- Iterator categories determine what algorithms you can use:
  * InputIterator / OutputIterator — single-pass (streams).
  * ForwardIterator — multi-pass, can read multiple times.
  * BidirectionalIterator — can ++ and -- (e.g., std::list).
  * RandomAccessIterator — supports +, -, indexing (e.g., std::vector, std::deque).

* Why it matters?
- Some algorithms require specific categories (e.g., std::sort requires RandomAccessIterator). Choosing the wrong container can block you from using an algorithm.

* Common pitfalls:
- Using std::sort on a std::list — not allowed because list iterators are bidirectional; std::list provides its own sort() member.
- Misunderstanding end() — it is past-the-end and must not be dereferenced.

_______________________________________________________________________________________
— STL algorithms and their iterator requirements:

* Concept & purpose:
- The <algorithm> library provides powerful, reusable algorithms (sort, find, min_element, max_element, for_each, etc.). They operate on iterator ranges.

* Why it matters?
- Algorithms are faster to write and use well-tested implementations, but you must pick a container whose iterators meet the algorithm’s requirements.

* Key rules:
- std::find works with InputIterator (very flexible).
- std::sort requires RandomAccessIterator (vector/deque ok; list not ok).
- If container iterators are insufficient, either use a container with the right iterator category or use container-specific algorithms (e.g., std::list::sort()).
_______________________________________________________________________________________
Choosing the underlying container: vector vs deque vs list:

Quick comparison:

* std::vector<T>
- Memory: contiguous.
- Access: random access (fast operator[]).
- push_back: amortized O(1), may reallocate and invalidate iterators.
- Good for algorithms requiring random access (like std::sort).

* std::deque<T>
- Memory: segmented blocks, still offers random access.
- push_front and push_back are O(1).
- Iterator invalidation rules differ from vector (less likely to reallocate everything).
- Default underlying container for std::stack.

* std::list<T> :
- Memory: nodes linked.
- push_back, insert, erase: O(1) with iterator stability.
- No random access (only bidirectional iterators). std::sort does not work; use list.sort() instead.

* Why it matters?
- The underlying container determines what algorithms you can apply to the iterators and what operations are cheap or expensive.

* Pitfalls:

- If you expose iterators and pick std::list, users can iterate perfectly but can’t use std::sort.
- If you pick vector, iterators can be invalidated after many push_back() calls.

* Practice: for each container (vector, deque, list) push 1000 integers, measure (or think about) which operations are O(1) vs O(n), and try to call std::sort() — note which containers allow it.