
conversion types:
- static_cast: normal conversions (safe, checked at compile time).
- dynamic_cast: downcasting with runtime checks.
- const_cast: add/remove const/volatile.
- reinterpret_cast: unsafe low-level conversions.
__________________________________________________________________
‚úÖ Compile-time vs Runtime checks in type casting

üîπ Compile-time check

The compiler can already see if the cast is possible based on types.

Example:

//double d = 3.14;
//int i = static_cast<int>(d);   // ‚úÖ compiler allows
//std::string s = static_cast<std::string>(d); // ‚ùå compiler error

Here, static_cast fails at compile-time if no valid conversion exists.
So static_cast guarantees at compile-time that you‚Äôre not casting nonsense types.

üîπ Runtime check

Some things can only be verified when the program is running (not at compile time).
That‚Äôs where dynamic_cast comes in.

Example:

//#include <iostream>
//
//class Base { public: virtual ~Base() {} }; // must be polymorphic
//class Derived : public Base {};
//class Other : public Base {};
//
//Base* b = new Base();
//
//Derived* d = dynamic_cast<Derived*>(b); // ‚ùå runtime check
//if (d == nullptr) {
//    std::cout << "b is not actually a Derived" << std::endl;
//}

- At compile-time: The compiler says, ‚ÄúBase* can be cast to Derived*.‚Äù (because of inheritance relation).

- At runtime: The program checks the actual object type that b points to.
    * If b really points to a Derived, the cast works.
    * If b points to a Base (or something else), dynamic_cast returns nullptr.

That‚Äôs what runtime checked means:
üëâ The compiler allows the cast, but the program checks the real object type while running.

‚ö° Summary:

- static_cast: only compile-time checks ‚Üí "is this cast logically valid according to the type system?"
- dynamic_cast: compile-time check ‚Üí "are these classes related?" + runtime check ‚Üí "is the actual object really of that type?"

more clear example:
When you use pointers or references to base classes, the compiler only sees the base type, but at runtime the pointer may actually refer to a derived object.

Example:

//class Base { public: virtual ~Base() {} };
//class Derived : public Base {};
//class Other : public Base {};
//
//Base* b1 = new Derived(); // actual object = Derived
//Base* b2 = new Other();   // actual object = Other
//Base* b3 = new Base();    // actual object = Base

Here:
* b1, b2, and b3 are all Base* pointers.
* But the actual objects in memory are different (Derived, Other, Base).

üîπ How dynamic_cast uses this

//Derived* d1 = dynamic_cast<Derived*>(b1); // ‚úÖ works, actual object is Derived
//Derived* d2 = dynamic_cast<Derived*>(b2); // ‚ùå fails, actual object is Other
//Derived* d3 = dynamic_cast<Derived*>(b3); // ‚ùå fails, actual object is Base

* At compile-time, the compiler says: ‚ÄúYes, Base and Derived are related, so casting is allowed.‚Äù
* At runtime, the program looks at the actual object stored in memory (Derived, Other, Base) and checks:
    - If the object is really a Derived, the cast succeeds.
    - Otherwise, it returns nullptr (for pointers) or throws std::bad_cast (for references).

__________________________________________________________________

FLOAT:

* A float can only store some numbers exactly, not all of them. When the number is very big,
float skips a lot of numbers in between. So, if you give it a big number, it might round it to
the closest one it can store. That‚Äôs why you don‚Äôt always get the exact number you put in,
even if it‚Äôs within the float‚Äôs range.

A float stores numbers kind of like scientific notation, but in binary.
For example, in decimal, 123,000 can be written as 1.23 √ó 10‚Åµ.
In binary, a float stores numbers as:
mantissa √ó 2^(exponent)

The mantissa is the main digits of the number.
The exponent says how many times to multiply (or divide) by 2.
Example:
If you want to store 8 as a float, it‚Äôs 1 √ó 2¬≥ (mantissa = 1, exponent = 3).
If you want to store 0.5, it‚Äôs 1 √ó 2‚Åª¬π (mantissa = 1, exponent = -1).

Why does this matter?

The float has only 32 bits to store everything.
Some bits are for the mantissa (the digits), some for the exponent (the power of 2), and 1 bit for the sign (+ or -).
The bigger the exponent, the less detail you can keep in the mantissa.
So, floats can store very big or very small numbers, but not all numbers in between, because they have to ‚Äúshare‚Äù the bits between the mantissa and the exponent.
That‚Äôs why, for big numbers, floats skip some values‚Äîthey don‚Äôt have enough bits to store every possible number exactly.

Example:
Let‚Äôs say a float has only 3 digits for the mantissa (just for illustration; real floats have more).

If you store a small number:

1.23 √ó 10¬π (mantissa: 1.23, exponent: 1)
You can keep all 3 digits: 1.23
If you store a big number:

1.23 √ó 10‚Å∂ (mantissa: 1.23, exponent: 6)
Still 3 digits: 1.23, but now the number is much bigger.
But what if you want to store 1,234,567?

In scientific notation: 1.23 √ó 10‚Å∂ (rounded, only 3 digits kept)
The real number is 1,234,567, but you only keep 1.23 √ó 10‚Å∂ = 1,230,000
So, as the exponent gets bigger, you lose the ability to store the exact digits after the first few.
For very big numbers, you can only keep the first few digits, and the rest are rounded off.

This is why, with big exponents, floats can‚Äôt store all the details‚Äîthey run out of space for the mantissa!

In reality:

For a 32-bit float (in C++), the mantissa is 23 bits long (about 7 decimal digits of precision).
For a 64-bit double, the mantissa is 52 bits long (about 16 decimal digits of precision).
So, the mantissa‚Äôs size depends on the type (float or double), and it‚Äôs measured in bits, not decimal digits. The more bits, the more detail (precision) you can store.
__________________________________________________________________

Key characteristics and uses of uintptr_t:


__________________________________________________________________
the max digits of number for double to try it
./scalarConverter 55555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555




__________________________________________________________________
// void ScalarConverter::convert(std::string c)
// {

//     std::istringstream iss(c);
//     double nb;
//     iss >> nb;
//     if (!iss.fail())
//     {
//         if(iss.eof())
//         {
//             Digit(nb);
//             return ;
//         }
//         else if(iss.peek() == 'f')
//         {
//             iss.get();
//             if (iss.peek() == EOF)
//             {
//                 if(isValidFloat(c))
//                     Digit(nb);
//                 else
//                 {
//                     std::cout<<"char: impossible"<<std::endl;
//                     std::cout<<"int: impossible"<<std::endl;
//                     std::cout<<"float: impossible"<<std::endl;
//                     std::cout<<"double: impossible"<<std::endl;
//                 }
//             }
//             else
//             {
//                 std::cout<<"char: impossible"<<std::endl;
//                 std::cout<<"int: impossible"<<std::endl;
//                 std::cout<<"float: impossible"<<std::endl;
//                 std::cout<<"double: impossible"<<std::endl;
//             }
//         }
//     }
//     std::string remaining;
//     iss >> remaining;
//     std::cout<<remaining<<std::endl;
//     if (!remaining.empty())
//     {
//         std::cout<<"char: impossible"<<std::endl;
//         std::cout<<"int: impossible"<<std::endl;
//         std::cout<<"float: impossible"<<std::endl;
//         std::cout<<"double: impossible"<<std::endl;
//         return ;
//     }
//     else if (remaining.length() == 1 && !isdigit(remaining[0]))
//     {
//         nb = static_cast<double>(remaining[0]);
//         Digit(nb);
//         return ;
//     }
//     else if (pseudoLiterals(c))
//         return ;
//     else if (nb >= DBL_MAX || nb <= DBL_MIN)
//     {
//         std::cout<<"char: impossible"<<std::endl;
//         std::cout<<"int: impossible"<<std::endl;
//         std::cout<<"float: impossible"<<std::endl;
//         std::cout<<"double: impossible"<<std::endl;
//         return ;
//     }
//     else if (c.length() == 1 && !isdigit(c[0]))
//     {
//         nb = static_cast<double>(c[0]);
//         Digit(nb);
//     }
//     else
//     {
//         std::cout<<"char: impossible"<<std::endl;
//         std::cout<<"int: impossible"<<std::endl;
//         std::cout<<"float: impossible"<<std::endl;
//         std::cout<<"double: impossible"<<std::endl;
//     }
// }
