
conversion types:
- static_cast: normal conversions (safe, checked at compile time).
- dynamic_cast: downcasting with runtime checks.
- const_cast: add/remove const/volatile.
- reinterpret_cast: unsafe low-level conversions.
__________________________________________________________________
âœ… Compile-time vs Runtime checks in type casting

ğŸ”¹ Compile-time check

The compiler can already see if the cast is possible based on types.

Example:

//double d = 3.14;
//int i = static_cast<int>(d);   // âœ… compiler allows
//std::string s = static_cast<std::string>(d); // âŒ compiler error

Here, static_cast fails at compile-time if no valid conversion exists.
So static_cast guarantees at compile-time that youâ€™re not casting nonsense types.

ğŸ”¹ Runtime check

Some things can only be verified when the program is running (not at compile time).
Thatâ€™s where dynamic_cast comes in.

Example:

//#include <iostream>
//
//class Base { public: virtual ~Base() {} }; // must be polymorphic
//class Derived : public Base {};
//class Other : public Base {};
//
//Base* b = new Base();
//
//Derived* d = dynamic_cast<Derived*>(b); // âŒ runtime check
//if (d == nullptr) {
//    std::cout << "b is not actually a Derived" << std::endl;
//}

- At compile-time: The compiler says, â€œBase* can be cast to Derived*.â€ (because of inheritance relation).

- At runtime: The program checks the actual object type that b points to.
    * If b really points to a Derived, the cast works.
    * If b points to a Base (or something else), dynamic_cast returns nullptr.

Thatâ€™s what runtime checked means:
ğŸ‘‰ The compiler allows the cast, but the program checks the real object type while running.

âš¡ Summary:

- static_cast: only compile-time checks â†’ "is this cast logically valid according to the type system?"
- dynamic_cast: compile-time check â†’ "are these classes related?" + runtime check â†’ "is the actual object really of that type?"

more clear example:
When you use pointers or references to base classes, the compiler only sees the base type, but at runtime the pointer may actually refer to a derived object.

Example:

//class Base { public: virtual ~Base() {} };
//class Derived : public Base {};
//class Other : public Base {};
//
//Base* b1 = new Derived(); // actual object = Derived
//Base* b2 = new Other();   // actual object = Other
//Base* b3 = new Base();    // actual object = Base

Here:
* b1, b2, and b3 are all Base* pointers.
* But the actual objects in memory are different (Derived, Other, Base).

ğŸ”¹ How dynamic_cast uses this

//Derived* d1 = dynamic_cast<Derived*>(b1); // âœ… works, actual object is Derived
//Derived* d2 = dynamic_cast<Derived*>(b2); // âŒ fails, actual object is Other
//Derived* d3 = dynamic_cast<Derived*>(b3); // âŒ fails, actual object is Base

* At compile-time, the compiler says: â€œYes, Base and Derived are related, so casting is allowed.â€
* At runtime, the program looks at the actual object stored in memory (Derived, Other, Base) and checks:
    - If the object is really a Derived, the cast succeeds.
    - Otherwise, it returns nullptr (for pointers) or throws std::bad_cast (for references).

__________________________________________________________________

FLOAT:

* A float can only store some numbers exactly, not all of them. When the number is very big,
float skips a lot of numbers in between. So, if you give it a big number, it might round it to
the closest one it can store. Thatâ€™s why you donâ€™t always get the exact number you put in,
even if itâ€™s within the floatâ€™s range.

A float stores numbers kind of like scientific notation, but in binary.
For example, in decimal, 123,000 can be written as 1.23 Ã— 10âµ.
In binary, a float stores numbers as:
mantissa Ã— 2^(exponent)

The mantissa is the main digits of the number.
The exponent says how many times to multiply (or divide) by 2.
Example:
If you want to store 8 as a float, itâ€™s 1 Ã— 2Â³ (mantissa = 1, exponent = 3).
If you want to store 0.5, itâ€™s 1 Ã— 2â»Â¹ (mantissa = 1, exponent = -1).

Why does this matter?

The float has only 32 bits to store everything.
Some bits are for the mantissa (the digits), some for the exponent (the power of 2), and 1 bit for the sign (+ or -).
The bigger the exponent, the less detail you can keep in the mantissa.
So, floats can store very big or very small numbers, but not all numbers in between, because they have to â€œshareâ€ the bits between the mantissa and the exponent.
Thatâ€™s why, for big numbers, floats skip some valuesâ€”they donâ€™t have enough bits to store every possible number exactly.

Example:
Letâ€™s say a float has only 3 digits for the mantissa (just for illustration; real floats have more).

If you store a small number:

1.23 Ã— 10Â¹ (mantissa: 1.23, exponent: 1)
You can keep all 3 digits: 1.23
If you store a big number:

1.23 Ã— 10â¶ (mantissa: 1.23, exponent: 6)
Still 3 digits: 1.23, but now the number is much bigger.
But what if you want to store 1,234,567?

In scientific notation: 1.23 Ã— 10â¶ (rounded, only 3 digits kept)
The real number is 1,234,567, but you only keep 1.23 Ã— 10â¶ = 1,230,000
So, as the exponent gets bigger, you lose the ability to store the exact digits after the first few.
For very big numbers, you can only keep the first few digits, and the rest are rounded off.

This is why, with big exponents, floats canâ€™t store all the detailsâ€”they run out of space for the mantissa!

In reality:

For a 32-bit float (in C++), the mantissa is 23 bits long (about 7 decimal digits of precision).
For a 64-bit double, the mantissa is 52 bits long (about 16 decimal digits of precision).
So, the mantissaâ€™s size depends on the type (float or double), and itâ€™s measured in bits, not decimal digits. The more bits, the more detail (precision) you can store.
__________________________________________________________________

Key characteristics and uses of uintptr_t:


__________________________________________________________________
the max digits of number for double to try it
./scalarConverter 55555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555


__________________________________________________________________


1. Upcasting (Derived â†’ Base)
- Always safe. No runtime check needed.

//class Base { };
//class Derived : public Base { };

//Derived* d = new Derived;
//Base* b = static_cast<Base*>(d);  // Safe upcast

2. Downcasting (Base â†’ Derived)
- Safe only if the object really is of the derived type.
- You must know that the object is actually Derived.

//class Base { virtual void f() {} };
//class Derived : public Base { };

Base* b = new Derived;

// You are sure that b points to Derived:
Derived* d = static_cast<Derived*>(b);  // Safe

âš  If b actually points to a Base object, this cast is undefined behavior.
3. Across sibling classes
- Not safe. static_cast cannot convert between unrelated derived classes.

//class Base { };
//class Derived1 : public Base { };
//class Derived2 : public Base { };

//Base* b = new Derived1;
// This is illegal with static_cast:
// Derived2* d2 = static_cast<Derived2*>(b); // Compile error

âœ… Rule of thumb
- Upcast â†’ always safe.
- Downcast â†’ only use if you are 100% sure of the object type.
- Dynamic_cast â†’ use if you need runtime safety for downcasts.


| Cast Type      | From â†’ To           | Safe?                             | Notes                              |
| -------------- | ------------------- | --------------------------------  | ---------------------------------- |
| `static_cast`  | Derived â†’ Base      | âœ… Always safe                    | Upcasting; compile-time check only |
| `static_cast`  | Base â†’ Derived      | âš  Only if actual type matches     | Downcasting; **no runtime check**  |
| `static_cast`  | Derived1 â†’ Derived2 | âŒ Unsafe / Compile error         | Siblings; unrelated types          |
| `dynamic_cast` | Base â†’ Derived      | âœ… Safe; returns nullptr if wrong | Runtime check included             |
| `dynamic_cast` | Derived â†’ Base      | âœ… Always safe                    | Same as `static_cast` for upcast   |
| `dynamic_cast` | Derived1 â†’ Derived2 | âŒ Returns nullptr                | Safe runtime check prevents UB     |
